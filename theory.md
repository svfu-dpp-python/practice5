# Теоретическая часть

## Введение

Модуль — это скрипт на языке Python (файл с расширением `*.py`).

Пакет — это каталог с файлом `__init__.py`. Файл `__init__.py` является заголовком пакета и содержит перечень идентификаторов, которые становятся доступными при импорте пакета.

Пакет состоит из некоторого количества вложенных модулей и пакетов.

Подключение модуля или пакета происходит с помощью ключевых слов `import` и `from`. При этом нужно указать имя каталога (если подключается пакет) или имя файла без расширения `*.py` (если подключается модуль).

При подключении модуля или пакета происходит выполнение импортируемого модуля или заголовка пакета. В ходе выполнения Python регистрирует имена созданных объектов:

* модулей/пакетов
* переменных
* функций
* классов

```python
# при импорте Python выполняет модуль/пакет и дает доступ к его именам
import os

# обращаемся к переменной по имени path из модуля os
print(os.getcwd())
```

При импорте Python просматривает определенный перечень каталогов который хранится в списке `path` из модуля `sys`. В каждом каталоге он ищет нужный модуль/пакет. Как только он найден, поиск прекращается. Текущий каталог также входит в этот перечень и просматривается в первую очередь.

Если модуль/пакет импортируется повторно, то повторного выполнения не происходит. Вместо этого все необходимые имена берутся из кеша созданного при первом импорте.

При импорте программист может указать имя пакета/модуля в целом, либо указать определенные имена из него:

```python
# Импорт модулей/пакетов в целом
import os

# Импортирование может перемежаться со строками обычного кода,
# однако рекомендуется по возможности расположить импорты в начале модуля
print(os.getcwd())

# Импорт определенных имен из модуля/пакета
from datetime import date
from math import cos, sin, PI

# Если из модуля импортируется очень много имен, то рекомендуется заключить их
# в скобки и разбить на несколько строк
from collections import (namedtuple, deque, ChainMap, Counter, OrderedDict,
                         defaultdict, UserDict, UserList, UserString)

print(PI)
```

**Не рекомендуется** импортировать все имена из модуля, т.к. это может привести к импорту ненужных вам имен:

```python
from math import *
```

## Псевдонимы

При импорте можно назначить имени исходного объекта псевдоним (для удобства использования, или чтобы избежать конфликта имен):

```python
import math as m
from math import sin as s

print(s(m.PI))
```

## Вложенные пакеты

Внутри пакета можно создать вложенные пакеты. Глубина вложенности не ограничивается, но на практике достаточно 2-3 уровней вложенности.

Чтобы импортировать имена из вложенного модуля/пакета нужно последовательно указать цепочку пакетов соединённых точкой:

```python
from os.path import getsize

print(f"This file is {getsize(__file__)} bytes long.")
```

## Относительная адресация

Представим ситуацию, когда внутри некоторого проекта создан пакет `package`. Внутри него находятся два модуля `module1.py` и `module2.py`. Тогда импортировать имена из одного в соседний возможно двумя разными способами:

```python
# обычный способ
from package.module1 import func1

# относительная адресация, обратите внимание на точку перед именем модуля
from .module1 import func2

print(func2())
```

Относительная адресация использует точку перед именем модуля/пакета, чтобы указать что он импортируется из текущего пакета.

Относительная адресация использует две точки перед именем модуля/пакета, чтобы указать что он импортируется из родительского пакета.

Возможно и большее количество точек перед именем модуля/пакета, но обычно этого не требуется.

## Проблема циклического импорта

В описанном выше механизме импорта имен имеется возможность возможность повторного импорта одного имени по цепочке.

Например, предположим что в `module1.py` объявлена функция `function`. Её можно импортировать в модуль `module2.py`. Затем её можно импортировать в `module3.py` либо из `module1.py` либо из `module2.py`. Оба варианта допустимы.

Возможны и более длинные цепочки импортов, но на практике достаточно цепочек из 1-2 звеньев.

Иногда начинающие программисты создают замкнутые цепочки импортов. Например, если `module1.py` импортирует `module2.py`, а тот в свою очередь снова импортирует `module1.py`.

Чтобы решить эту проблему нужно убрать один из проблемных импортов и реорганизовать код.

## Функция `globals()` и системные переменные

Встроенная функция `globals()` возвращает словарь переменных текущего пространства имен (контекста).

Системная переменная `__doc__` содержит строку документации (см. ниже) модуля.

Системная переменная `__name__` содержит полное имя модуля либо значение "`__main__`" для стартового модуля.

Системная переменная `__file__` содержит имя файла модуля.

Системная переменная `__package__` содержит имя пакета.

Системная переменная `__path__` содержит путь к пакету. Присутствует только в заголовке пакета.

Системная переменная `__all__` используется чтобы указать список или кортеж имен которые нужно импортировать если происходит импорт со звездочкой. Если переменная не задана, то будет происходить импорт всех имен.

```python
if __name__ == '__main__':
    # это сообщение будет видно только непосредственном запуске модуля
    # при импорте модуля - оно будет пропускаться
    print('Привет из стартового модуля!')
```

## Строки документации

Каждая функция, класс, модуль или пакет могут содержать строку документации. Строки документации оформляются следующим образом:

```python
def a_plus_b(a, b):
    """ Эта функция складывает два числа """
    return a + b

def a_mult_b(a, b):
    """ Эта функция перемножает два числа
    :param a: число A
    :param b: число B
    :return: произведение чисел A и B
    """
    return a * b
```

Строки документации позволяют IDE (интегрированным средам разработки) показывать программисту умные подсказки.

## Пакеты сторонних разработчиков

На сайте http://pypi.org/ перечислены пакеты опубликованные сторонними разработчиками.

Скрипт `pip` позволяет устанавливать такие пакеты:

```bash
pip install flask
```

Часто для корректной работы одному пакету нужно наличие какого-то другого пакета.

Скрипт `pip` автоматически находит необходимые пакеты и скачивает их из Интернета по ссылкам с сайта http://pypi.org/.

## Бинарные пакеты

Python написан на языках C/C++ и имеет возможность вызывать определенным образом подготовленные функции из этих языков. Поэтому в Python часто применяются модули и пакеты написанные на C/C++. Такие модули называются бинарными.

Т.к. С/С++ — это компилируемые языки, то бинарные модули перед использованием должны быть скомпилированы (при этом их исходный код превращается в машинный код). При компиляции они привязываются:

* к определенной операционной системе;
* к архитектуре процессора;
* к версии интерпретатора Python (учитываются только первые два числа в версии, третье — несущественна).

Например, если бинарный пакет скомпилирован для Windows, то его нельзя использовать на macOS или Linux. Если он скомпилирован для Python 3.9, то его нельзя использовать на Python 3.10.

При публикации бинарных пакетов авторы компилируют его для наиболее популярных комбинаций ОС / процессор / интерпретатор. Если подходящего для вас бинарного пакета нет (например если вы установили свежую версию Python которая вышла меньше месяца назад), то pip попытается скомпилировать его на вашем компьютере. Для этого нужен компилятор C/C++, однако если он не найден или не подходит, то pip выдаст ошибку.

Использование бинарных пакетов позволяет значительно эффективнее использовать ресурсы компьютера, чем обычный пакет на Python.
